import Foundation
import UserNotifications
import UIKit
#if canImport(FirebaseMessaging)
import FirebaseMessaging
#endif
#if canImport(FirebaseCore)
import FirebaseCore
#endif

// MARK: - ÏïåÎ¶º ÏÑúÎπÑÏä§
class NotificationService: ObservableObject {
    static let shared = NotificationService()
    
    @Published var isNotificationEnabled = false
    @Published var deviceId: Int? = nil
    @Published var festivalNotificationId: Int? = nil
    @Published var fcmToken: String? = nil
    @Published var isTokenGenerating = false

    private let userDefaults = UserDefaults.standard
    private let deviceIdKey = "deviceId"
    private let festivalNotificationIdKey = "festivalNotificationId"
    private let notificationEnabledKey = "notificationEnabled"
    private let notificationModalShownKey = "notificationModalShown_"
    private let fcmTokenKey = "fcmToken"
    
    private init() {
        loadStoredValues()
    }
    
    // MARK: - Ï†ÄÏû•Îêú Í∞í Î°úÎìú
    private func loadStoredValues() {
        deviceId = userDefaults.object(forKey: deviceIdKey) as? Int
        festivalNotificationId = userDefaults.object(forKey: festivalNotificationIdKey) as? Int
        isNotificationEnabled = userDefaults.bool(forKey: notificationEnabledKey)
        fcmToken = userDefaults.string(forKey: fcmTokenKey)
        print("[NotificationService] Loaded deviceId: \(deviceId ?? -1), festivalNotificationId: \(festivalNotificationId ?? -1), isNotificationEnabled: \(isNotificationEnabled), fcmToken: \(fcmToken?.prefix(20) ?? "nil")...")
    }
    
    // MARK: - ÎîîÎ∞îÏù¥Ïä§ ID Ï†ÄÏû•
    private func saveDeviceId(_ id: Int) {
        deviceId = id
        userDefaults.set(id, forKey: deviceIdKey)
    }
    
    // MARK: - Ï∂ïÏ†ú ÏïåÎ¶º ID Ï†ÄÏû•
    private func saveFestivalNotificationId(_ id: Int) {
        festivalNotificationId = id
        userDefaults.set(id, forKey: festivalNotificationIdKey)
    }
    
    // MARK: - ÏïåÎ¶º ÏÑ§Ï†ï Ï†ÄÏû•
    private func saveNotificationEnabled(_ enabled: Bool) {
        isNotificationEnabled = enabled
        userDefaults.set(enabled, forKey: notificationEnabledKey)
    }

    // MARK: - ÏïåÎ¶º ÏÑ§Ï†ï ÏóÖÎç∞Ïù¥Ìä∏ (public access)
    func updateNotificationEnabled(_ enabled: Bool) {
        saveNotificationEnabled(enabled)
        print("[NotificationService] ÏïåÎ¶º ÏÑ§Ï†ï ÏóÖÎç∞Ïù¥Ìä∏: \(enabled)")
    }
    
    // MARK: - ÏïåÎ¶º Í∂åÌïú ÏÉÅÌÉú ÌôïÏù∏
    func getNotificationAuthorizationStatus() async -> UNAuthorizationStatus {
        let settings = await UNUserNotificationCenter.current().notificationSettings()
        return settings.authorizationStatus
    }

    // MARK: - ÏïåÎ¶º Í∂åÌïú ÏöîÏ≤≠ (Í∂åÌïúÎßå ÏöîÏ≤≠, Íµ¨ÎèÖÏùÄ Îî∞Î°ú)
    func requestNotificationPermission() async -> Bool {
        print("[NotificationService] üìã ÏãúÏä§ÌÖú ÏïåÎ¶º Í∂åÌïú ÏöîÏ≤≠ ÏãúÏûë")

        let currentStatus = await getNotificationAuthorizationStatus()

        switch currentStatus {
        case .notDetermined:
            do {
                let granted = try await UNUserNotificationCenter.current().requestAuthorization(
                    options: [.alert, .badge, .sound]
                )

                print("[NotificationService] ‚úÖ ÏãúÏä§ÌÖú ÏïåÎ¶º Í∂åÌïú ÏöîÏ≤≠ Í≤∞Í≥º: \(granted ? "ÌóàÏö©" : "Í±∞Î∂Ä")")

                if granted {
                    // Í∂åÌïú ÌóàÏö© Ïãú APNs Îì±Î°ù
                    await MainActor.run {
                        if let appDelegate = UIApplication.shared.delegate as? AppDelegate {
                            appDelegate.registerForAPNS()
                        }
                    }
                }

                return granted
            } catch {
                print("[NotificationService] ‚ùå ÏãúÏä§ÌÖú ÏïåÎ¶º Í∂åÌïú ÏöîÏ≤≠ Ïã§Ìå®: \(error)")
                return false
            }

        case .denied:
            print("[NotificationService] ‚ö†Ô∏è ÏïåÎ¶º Í∂åÌïúÏù¥ Í±∞Î∂ÄÎêú ÏÉÅÌÉúÏûÖÎãàÎã§")
            return false

        case .authorized, .provisional, .ephemeral:
            print("[NotificationService] ‚úÖ ÏïåÎ¶º Í∂åÌïúÏù¥ Ïù¥ÎØ∏ ÌóàÏö©Îêú ÏÉÅÌÉúÏûÖÎãàÎã§")
            return true

        @unknown default:
            print("[NotificationService] ‚ùì Ïïå Ïàò ÏóÜÎäî Í∂åÌïú ÏÉÅÌÉú: \(currentStatus)")
            return false
        }
    }

    // MARK: - ÎîîÎ∞îÏù¥Ïä§ Îì±Î°ù ÏÉÅÌÉú ÌôïÏù∏
    func isDeviceRegistered() -> Bool {
        return deviceId != nil && deviceId! > 0
    }

    // MARK: - Ï∂ïÏ†ú Íµ¨ÎèÖ ÏÉÅÌÉú ÌôïÏù∏
    func isFestivalSubscribed() -> Bool {
        return festivalNotificationId != nil && festivalNotificationId! > 0
    }

    // MARK: - ÌòÑÏû¨ FCM ÌÜ†ÌÅ∞ Î∞òÌôò (Îã®Ïàú)
    func getCurrentFCMToken() -> String? {
        return fcmToken
    }

    // MARK: - ÌÜ†ÌÅ∞ ÏûêÎèô Í∞±Ïã† Ïãú ÏÑúÎ≤Ñ ÏóÖÎç∞Ïù¥Ìä∏
    func updateTokenToServerIfNeeded(_ token: String) async {
        // Í∏∞Ï°¥Ïóê ÎîîÎ∞îÏù¥Ïä§Í∞Ä Îì±Î°ùÎêòÏñ¥ ÏûàÍ≥†, ÌÜ†ÌÅ∞Ïù¥ Î≥ÄÍ≤ΩÎêú Í≤ΩÏö∞ÏóêÎßå ÏÑúÎ≤Ñ ÏóÖÎç∞Ïù¥Ìä∏
        guard let deviceId = deviceId, deviceId > 0 else {
            print("[NotificationService] ÎîîÎ∞îÏù¥Ïä§ ÎØ∏Îì±Î°ù ÏÉÅÌÉú - ÏÑúÎ≤Ñ ÏóÖÎç∞Ïù¥Ìä∏ Ïä§ÌÇµ")
            return
        }

        guard fcmToken != token else {
            print("[NotificationService] ÌÜ†ÌÅ∞ Î≥ÄÍ≤Ω ÏóÜÏùå - ÏÑúÎ≤Ñ ÏóÖÎç∞Ïù¥Ìä∏ Ïä§ÌÇµ")
            return
        }

        print("[NotificationService] ÌÜ†ÌÅ∞ Î≥ÄÍ≤Ω Í∞êÏßÄ - ÏÑúÎ≤ÑÏóê ÏóÖÎç∞Ïù¥Ìä∏ Ï§ë...")

        // TODO: ÎîîÎ∞îÏù¥Ïä§ ÌÜ†ÌÅ∞ ÏóÖÎç∞Ïù¥Ìä∏ API Ìò∏Ï∂ú Íµ¨ÌòÑ ÌïÑÏöî
        // do {
        //     let _ = try await updateDeviceToken(deviceId: deviceId, newToken: token)
        //     print("[NotificationService] ‚úÖ ÏÑúÎ≤Ñ ÌÜ†ÌÅ∞ ÏóÖÎç∞Ïù¥Ìä∏ ÏôÑÎ£å")
        // } catch {
        //     print("[NotificationService] ‚ùå ÏÑúÎ≤Ñ ÌÜ†ÌÅ∞ ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìå®: \(error)")
        // }

        print("[NotificationService] ‚úÖ ÏÑúÎ≤Ñ ÌÜ†ÌÅ∞ ÏóÖÎç∞Ïù¥Ìä∏ ÏôÑÎ£å (ÌòÑÏû¨ Íµ¨ÌòÑ ÎåÄÍ∏∞Ï§ë)")
    }
    
    // MARK: - FCM ÌÜ†ÌÅ∞ ÏóÖÎç∞Ïù¥Ìä∏ (AppDelegateÏóêÏÑú Ìò∏Ï∂ú)
    func updateFCMToken(_ token: String) {
        DispatchQueue.main.async {
            // Ïù¥Ï†Ñ ÌÜ†ÌÅ∞ÏùÑ Î®ºÏ†Ä Ï†ÄÏû• (ÎπÑÍµêÏö©)
            let previousToken = self.fcmToken

            // ÏÉà ÌÜ†ÌÅ∞ Ï†ÄÏû•
            self.fcmToken = token
            self.userDefaults.set(token, forKey: self.fcmTokenKey)
            print("[NotificationService] ‚úÖ ÏÉà FCM ÌÜ†ÌÅ∞ Ï†ÄÏû•")

            // FCM ÌÜ†ÌÅ∞ Î∞õÏúºÎ©¥ Ï¶âÏãú ÎîîÎ∞îÏù¥Ïä§ Îì±Î°ù (deviceId Ï†ÄÏû•Ïö©)
            Task {
                await self.registerDeviceIfNeeded(fcmToken: token, previousToken: previousToken)
            }
        }
    }

    // MARK: - ÎîîÎ∞îÏù¥Ïä§ Îì±Î°ù (ÌÜ†ÌÅ∞ Î≥ÄÍ≤Ω Ïãú Ìï≠ÏÉÅ ÏÉàÎ°ú Îì±Î°ù)
    private func registerDeviceIfNeeded(fcmToken: String, previousToken: String?) async {
        // ÌÜ†ÌÅ∞Ïù¥ Î≥ÄÍ≤ΩÎêòÏóàÍ±∞ÎÇò ÎîîÎ∞îÏù¥Ïä§Í∞Ä ÎØ∏Îì±Î°ù ÏÉÅÌÉúÎ©¥ ÏÉàÎ°ú Îì±Î°ù
        if !isDeviceRegistered() || previousToken != fcmToken {
            print("[NotificationService] FCM ÌÜ†ÌÅ∞ Î≥ÄÍ≤Ω Í∞êÏßÄ ÎòêÎäî ÎØ∏Îì±Î°ù - ÎîîÎ∞îÏù¥Ïä§ Îì±Î°ù ÏãúÏûë")
            print("[NotificationService] Ïù¥Ï†Ñ ÌÜ†ÌÅ∞: \(previousToken?.prefix(20) ?? "nil")...")
            print("[NotificationService] ÏÉà ÌÜ†ÌÅ∞: \(fcmToken.prefix(20))...")

            do {
                let registeredDeviceId = try await registerDevice(withToken: fcmToken)
                print("[NotificationService] ‚úÖ ÎîîÎ∞îÏù¥Ïä§ Îì±Î°ù ÏÑ±Í≥µ - deviceId: \(registeredDeviceId) Ï†ÄÏû•Îê®")
            } catch {
                print("[NotificationService] ‚ùå ÎîîÎ∞îÏù¥Ïä§ Îì±Î°ù Ïã§Ìå®: \(error)")
            }
        } else {
            print("[NotificationService] ÌÜ†ÌÅ∞ Î≥ÄÍ≤Ω ÏóÜÏùå - ÎîîÎ∞îÏù¥Ïä§ Îì±Î°ù Ïä§ÌÇµ")
        }
    }


    // MARK: - ÎîîÎ∞îÏù¥Ïä§ Îì±Î°ù
    func registerDevice(withToken fcmToken: String? = nil) async throws -> Int {
        let tokenToUse: String

        if let providedToken = fcmToken {
            tokenToUse = providedToken
            print("[NotificationService] ÎîîÎ∞îÏù¥Ïä§ Îì±Î°ù - Ï†úÍ≥µÎêú ÌÜ†ÌÅ∞ ÏÇ¨Ïö©: \(tokenToUse.prefix(20))...")
        } else {
            guard let currentToken = getCurrentFCMToken(), !currentToken.isEmpty else {
                throw NotificationError.fcmTokenNotFound
            }
            tokenToUse = currentToken
            print("[NotificationService] ÎîîÎ∞îÏù¥Ïä§ Îì±Î°ù - Ï†ÄÏû•Îêú ÌÜ†ÌÅ∞ ÏÇ¨Ïö©: \(tokenToUse.prefix(20))...")
        }

        let deviceIdentifier = await UIDevice.current.identifierForVendor?.uuidString ?? UUID().uuidString

        let request = DeviceRegistrationRequest(
            deviceIdentifier: deviceIdentifier,
            fcmToken: tokenToUse
        )
        
        let response: DeviceRegistrationResponse = try await APIClient.shared.postDevice(
            endpoint: Endpoints.devices,
            body: request
        )
        
        await MainActor.run {
            saveDeviceId(response.deviceId)
            print("[NotificationService] ÎîîÎ∞îÏù¥Ïä§ Îì±Î°ù ÏÑ±Í≥µ: \(response.deviceId)")
        }
        
        return response.deviceId
    }
    
    // MARK: - Ï∂ïÏ†ú ÏïåÎ¶º Íµ¨ÎèÖ
    func subscribeToFestivalNotifications(festivalId: Int) async throws -> Int {
        guard let deviceId = deviceId else {
            throw NotificationError.deviceNotRegistered
        }

        let request = FestivalNotificationRequest(deviceId: deviceId)
        let endpoint = "\(Endpoints.festivalNotifications)/\(festivalId)/notifications"

        // Use notification-specific POST method (no festival header)
        let response: FestivalNotificationResponse = try await APIClient.shared.postNotification(
            endpoint: endpoint,
            body: request
        )

        await MainActor.run {
            saveFestivalNotificationId(response.festivalNotificationId)
            saveNotificationEnabled(true)
            print("[NotificationService] Ï∂ïÏ†ú ÏïåÎ¶º Íµ¨ÎèÖ ÏÑ±Í≥µ: \(response.festivalNotificationId)")
        }

        return response.festivalNotificationId
    }
    
    // MARK: - Ï∂ïÏ†ú ÏïåÎ¶º Íµ¨ÎèÖ Ï∑®ÏÜå
    func unsubscribeFromFestivalNotifications() async throws {
        guard let festivalNotificationId = festivalNotificationId else {
            throw NotificationError.notificationNotSubscribed
        }

        let endpoint = "\(Endpoints.festivalNotificationCancel)/\(festivalNotificationId)"

        // Use notification-specific DELETE method (no festival header)
        try await APIClient.shared.deleteNotification(endpoint: endpoint)

        await MainActor.run {
            saveFestivalNotificationId(0) // 0ÏúºÎ°ú Î¶¨ÏÖã
            saveNotificationEnabled(false)
            print("[NotificationService] Ï∂ïÏ†ú ÏïåÎ¶º Íµ¨ÎèÖ Ï∑®ÏÜå ÏÑ±Í≥µ")
        }
    }
    
    // MARK: - ÏïåÎ¶º ÌÜ†Í∏Ä (ÏÑ§Ï†ï ÌôîÎ©¥ÏóêÏÑú ÏÇ¨Ïö©)
    func toggleNotification(festivalId: Int) async {
        do {
            if isNotificationEnabled {
                try await unsubscribeFromFestivalNotifications()
            } else {
                _ = try await subscribeToFestivalNotifications(festivalId: festivalId)
            }
        } catch {
            await MainActor.run {
                print("[NotificationService] ÏïåÎ¶º ÌÜ†Í∏Ä Ïã§Ìå®: \(error)")
            }
        }
    }
    
    // MARK: - ÌïôÍµêÎ≥Ñ Î™®Îã¨ ÌëúÏãú Ïó¨Î∂Ä Í¥ÄÎ¶¨
    func shouldShowNotificationModal(for festivalId: Int) -> Bool {
        let key = notificationModalShownKey + "\(festivalId)"
        return !userDefaults.bool(forKey: key)
    }
    
    func markNotificationModalShown(for festivalId: Int) {
        let key = notificationModalShownKey + "\(festivalId)"
        userDefaults.set(true, forKey: key)
        print("[NotificationService] ÌïôÍµê \(festivalId) Î™®Îã¨ ÌëúÏãú ÏôÑÎ£åÎ°ú Í∏∞Î°ù")
    }
}

// MARK: - ÏïåÎ¶º ÏóêÎü¨ ÌÉÄÏûÖ
enum NotificationError: Error, LocalizedError {
    case fcmTokenNotFound
    case deviceNotRegistered
    case notificationNotSubscribed
    
    var errorDescription: String? {
        switch self {
        case .fcmTokenNotFound:
            return "FCM ÌÜ†ÌÅ∞ÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§"
        case .deviceNotRegistered:
            return "ÎîîÎ∞îÏù¥Ïä§Í∞Ä Îì±Î°ùÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§"
        case .notificationNotSubscribed:
            return "ÏïåÎ¶ºÏù¥ Íµ¨ÎèÖÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§"
        }
    }
}
