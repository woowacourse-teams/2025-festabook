import SwiftUI

struct NewsRootView: View {
    enum Tab: String, CaseIterable {
        case notice = "Í≥µÏßÄ"
        case faq = "FAQ"
        case lost = "Î∂ÑÏã§Î¨º"
    }

    @State private var selectedTab: Tab = .notice
    @State private var showAnnouncementDetail = false
    @State private var selectedFestivalId = ""
    @State private var selectedAnnouncementId = ""
    
    // ÎØ∏Î¶¨ ÏÉùÏÑ±Îêú ViewModels - Ìôà ÏßÑÏûÖÏãú Î™®Îëê Î°úÎî©
    @StateObject private var announcementsViewModel = AnnouncementsViewModel(
        repository: ServiceLocator.shared.announcementsRepository
    )
    @StateObject private var faqViewModel = FAQViewModel(
        repository: ServiceLocator.shared.faqRepository
    )
    @StateObject private var lostItemViewModel = LostItemViewModel()

    var body: some View {
        NavigationStack {
            VStack(spacing: 0) {
                // ÏÉÅÎã® Ï†úÎ™© - ÏùºÏ†ï ÌôîÎ©¥Í≥º ÎèôÏùºÌïú Ïä§ÌÉÄÏùº
                HStack {
                    Text("ÏÜåÏãù")
                        .font(.system(size: 22, weight: .bold))
                        .foregroundColor(.primary)
                    Spacer()
                }
                .padding(.horizontal, 20)
                .padding(.top, 16)
                .padding(.bottom, 20)

                // Ïª§Ïä§ÌÖÄ ÌÉ≠Î∞î
                customTabBar

                // ÌÉ≠ ÎÇ¥Ïö©
                tabContent
            }
            .navigationDestination(isPresented: $showAnnouncementDetail) {
                AnnouncementDetailView(
                    festivalId: selectedFestivalId,
                    announcementId: selectedAnnouncementId
                )
            }
        }
        .task {
            // Ìôà ÏßÑÏûÖÏãú ÏÜåÏãù ÌÉ≠ Îç∞Ïù¥ÌÑ∞ Î™®Îëê ÎØ∏Î¶¨ Î°úÎî©
            async let announcementsTask = announcementsViewModel.loadAnnouncements()
            async let faqTask = faqViewModel.loadFAQs()
            async let lostItemTask = lostItemViewModel.loadInitialData()
            
            await (announcementsTask, faqTask, lostItemTask)
            print("[NewsRootView] Î™®Îì† ÏÜåÏãù Îç∞Ïù¥ÌÑ∞ Î°úÎî© ÏôÑÎ£å")
        }
        .onReceive(NotificationCenter.default.publisher(for: .showAnnouncementDetail)) { notification in
            if let data = notification.object as? [String: Any],
               let festivalId = data["festivalId"] as? String,
               let announcementId = data["announcementId"] as? String {

                print("[NewsRootView] üì¢ Í≥µÏßÄÏÇ¨Ìï≠ ÏÉÅÏÑ∏ ÌôîÎ©¥ ÌëúÏãú ÏöîÏ≤≠: festivalId=\(festivalId), announcementId=\(announcementId)")

                selectedFestivalId = festivalId
                selectedAnnouncementId = announcementId
                showAnnouncementDetail = true
            }
        }
    }

    private var customTabBar: some View {
        HStack(spacing: 0) {
            ForEach(Tab.allCases, id: \.self) { tab in
                Button(action: {
                    selectedTab = tab
                }) {
                    VStack(spacing: 8) {
                        Text(tab.rawValue)
                            .font(.system(size: 16, weight: .medium))
                            .foregroundColor(selectedTab == tab ? .black : .gray)

                        // ÌïòÎã® Î∞ëÏ§Ñ
                        Rectangle()
                            .fill(selectedTab == tab ? Color.black : Color.clear)
                            .frame(height: 2)
                    }
                }
                .frame(maxWidth: .infinity)
            }
        }
        .padding(.horizontal, 20)
        .padding(.bottom, 1)
    }

    private var tabContent: some View {
        TabView(selection: $selectedTab) {
            AnnouncementsListView(viewModel: announcementsViewModel)
                .tag(Tab.notice)
            
            FAQListView(viewModel: faqViewModel)
                .tag(Tab.faq)
            
            LostFoundListView(viewModel: lostItemViewModel)
                .tag(Tab.lost)
        }
        .tabViewStyle(PageTabViewStyle(indexDisplayMode: .never))
        .animation(.easeInOut(duration: 0.2), value: selectedTab)
    }
}

struct AnnouncementsListView: View {
    @ObservedObject var viewModel: AnnouncementsViewModel
    @EnvironmentObject private var appState: AppState
    @State private var expandedAnnouncementIds: Set<Int> = []
    @State private var pendingAnnouncementId: Int?

    var body: some View {
        ScrollViewReader { proxy in
            ScrollView {
                LazyVStack(spacing: 12) {
                    if viewModel.isLoading && viewModel.pinnedAnnouncements.isEmpty && viewModel.unpinnedAnnouncements.isEmpty {
                        ProgressView("Í≥µÏßÄÏÇ¨Ìï≠ÏùÑ Î∂àÎü¨Ïò§Îäî Ï§ë...")
                            .padding(.vertical, 40)
                    } else if !viewModel.isLoading && viewModel.pinnedAnnouncements.isEmpty && viewModel.unpinnedAnnouncements.isEmpty {
                        if let errorMessage = viewModel.errorMessage {
                            VStack(spacing: 12) {
                                Image(systemName: "exclamationmark.triangle")
                                    .font(.system(size: 24))
                                    .foregroundColor(.gray)
                                Text(errorMessage)
                                    .font(.system(size: 14))
                                    .foregroundColor(.gray)
                                    .multilineTextAlignment(.center)
                            }
                            .padding(.vertical, 40)
                        } else {
                            VStack(spacing: 12) {
                                Image(systemName: "doc.text")
                                    .font(.system(size: 24))
                                    .foregroundColor(.gray)
                                Text("Îì±Î°ùÎêú Í≥µÏßÄÏÇ¨Ìï≠Ïù¥ ÏóÜÏäµÎãàÎã§")
                                    .font(.system(size: 14))
                                    .foregroundColor(.gray)
                            }
                            .padding(.vertical, 40)
                        }
                    } else {
                        ForEach(viewModel.pinnedAnnouncements) { announcement in
                            AnnouncementCard(
                                announcement: announcement,
                                isExpanded: expandedAnnouncementIds.contains(announcement.announcementId),
                                onToggle: { toggleExpansion(for: announcement.announcementId) }
                            )
                            .id(announcement.announcementId)
                        }

                        ForEach(viewModel.unpinnedAnnouncements) { announcement in
                            AnnouncementCard(
                                announcement: announcement,
                                isExpanded: expandedAnnouncementIds.contains(announcement.announcementId),
                                onToggle: { toggleExpansion(for: announcement.announcementId) }
                            )
                            .id(announcement.announcementId)
                        }
                    }
                }
                .padding(.horizontal, 20)
                .padding(.top, 16)
                .padding(.bottom, 100)
            }
            .refreshable {
                await viewModel.loadAnnouncements()
                if let id = appState.pendingAnnouncementId {
                    pendingAnnouncementId = id
                    attemptExpansionIfNeeded(using: proxy)
                }
            }
            .onAppear {
                if let id = appState.pendingAnnouncementId {
                    pendingAnnouncementId = id
                    attemptExpansionIfNeeded(using: proxy)
                }
            }
            .onChange(of: appState.pendingAnnouncementId) { newValue in
                guard let id = newValue else { return }
                pendingAnnouncementId = id
                attemptExpansionIfNeeded(using: proxy)
            }
            .onChange(of: viewModel.pinnedAnnouncements) { _ in
                pruneInvalidExpandedIds()
                attemptExpansionIfNeeded(using: proxy)
            }
            .onChange(of: viewModel.unpinnedAnnouncements) { _ in
                pruneInvalidExpandedIds()
                attemptExpansionIfNeeded(using: proxy)
            }
            .onChange(of: appState.currentFestivalId) { _ in
                Task {
                    await viewModel.loadAnnouncements()
                    if let id = appState.pendingAnnouncementId {
                        pendingAnnouncementId = id
                        attemptExpansionIfNeeded(using: proxy)
                    }
                    pruneInvalidExpandedIds()
                }
            }
        }
    }

    private func toggleExpansion(for announcementId: Int) {
        if expandedAnnouncementIds.contains(announcementId) {
            expandedAnnouncementIds.remove(announcementId)
        } else {
            expandedAnnouncementIds.insert(announcementId)
        }
    }

    private func attemptExpansionIfNeeded(using proxy: ScrollViewProxy) {
        guard let targetId = pendingAnnouncementId else { return }

        let allAnnouncements = viewModel.pinnedAnnouncements + viewModel.unpinnedAnnouncements
        guard allAnnouncements.contains(where: { $0.announcementId == targetId }) else { return }

        pendingAnnouncementId = nil
        expandedAnnouncementIds.insert(targetId)

        DispatchQueue.main.async {
            withAnimation(.easeInOut) {
                proxy.scrollTo(targetId, anchor: .top)
            }
            appState.pendingAnnouncementId = nil
        }
    }

    private func pruneInvalidExpandedIds() {
        let validIds = Set((viewModel.pinnedAnnouncements + viewModel.unpinnedAnnouncements).map { $0.announcementId })
        expandedAnnouncementIds = expandedAnnouncementIds.intersection(validIds)
    }
}

struct AnnouncementCard: View {
    let announcement: Announcement
    let isExpanded: Bool
    let onToggle: () -> Void

    var body: some View {
        Button(action: {
            withAnimation(.easeInOut(duration: 0.3)) {
                onToggle()
            }
        }) {
            VStack(alignment: .leading, spacing: 0) {
                // ÏÉÅÎã®: ÏïÑÏù¥ÏΩò + Ï†úÎ™© + ÏãúÍ∞Ñ (Ìïú Ï§Ñ)
                HStack(alignment: .center, spacing: 8) {
                    // ÏôºÏ™Ω ÏïÑÏù¥ÏΩò (Îçî ÏûëÍ≤å)
                    Image(systemName: announcement.isPinned ? "pin.fill" : "speaker.wave.2.fill")
                        .font(.system(size: 14))
                        .foregroundColor(announcement.isPinned ? .gray : .black)
                        .frame(width: 16)

                    // Ï†úÎ™©
                    Text(announcement.title)
                        .font(.system(size: 16, weight: .medium))
                        .foregroundColor(.black)
                        .multilineTextAlignment(.leading)
                        .frame(maxWidth: .infinity, alignment: .leading)

                    // ÏãúÍ∞Ñ
                    Text(announcement.displayTime)
                        .font(.system(size: 12))
                        .foregroundColor(.gray)
                }
                .padding(.bottom, isExpanded ? 8 : 0)

                // ÌïòÎã®: Î≥∏Î¨∏ (ÌéºÏ≥êÏ°åÏùÑ ÎïåÎßå ÌëúÏãú, ÏïÑÏù¥ÏΩò ÏïÑÎûò Ï†ïÎ†¨)
                if isExpanded {
                    HStack(alignment: .top, spacing: 8) {
                        // ÏïÑÏù¥ÏΩò ÏòÅÏó≠ (Ìà¨Î™Ö, Ï†ïÎ†¨ÏùÑ ÏúÑÌï¥)
                        Color.clear
                            .frame(width: 16)

                        // Î≥∏Î¨∏
                        Text(LinkHelper.createAttributedString(from: announcement.content))
                            .font(.system(size: 14))
                            .foregroundColor(.black)
                            .multilineTextAlignment(.leading)
                            .lineLimit(nil)
                            .frame(maxWidth: .infinity, alignment: .leading)
                    }
                    .transition(.opacity.combined(with: .scale(scale: 0.95, anchor: .top)))
                }
            }
            .padding(16)
            .background(
                RoundedRectangle(cornerRadius: 12)
                    .fill(backgroundColor)
                    .overlay(
                        RoundedRectangle(cornerRadius: 12)
                            .stroke(Color.gray.opacity(0.4), lineWidth: 1)
                    )
            )
        }
        .buttonStyle(PlainButtonStyle())
    }

    private var backgroundColor: Color {
        announcement.isPinned ? Color(red: 0.97, green: 0.97, blue: 0.97) : Color.white
    }
}

@MainActor
class AnnouncementsViewModel: ObservableObject {
    @Published var pinnedAnnouncements: [Announcement] = []
    @Published var unpinnedAnnouncements: [Announcement] = []
    @Published var isLoading = false
    @Published var errorMessage: String?

    private let repository: AnnouncementsRepository
    private var loadTask: Task<Void, Never>?

    init(repository: AnnouncementsRepository) {
        self.repository = repository
    }

    func loadAnnouncements() async {
        // Í∏∞Ï°¥ Task Ï∑®ÏÜå
        loadTask?.cancel()

        // ÏÉàÎ°úÏö¥ Task ÏÉùÏÑ±
        loadTask = Task {
            await performLoad()
        }

        await loadTask?.value
    }

    private func performLoad() async {
        print("[AnnouncementsViewModel] üìû API Ìò∏Ï∂ú ÏãúÏûë - Í≥µÏßÄÏÇ¨Ìï≠ Î°úÎìú")
        isLoading = true
        errorMessage = nil

        // ÏÉàÎ°úÍ≥†Ïπ® ÌëúÏãúÎ•º ÏúÑÌï¥ Îç∞Ïù¥ÌÑ∞ Ï¥àÍ∏∞Ìôî
        pinnedAnnouncements = []
        unpinnedAnnouncements = []

        do {
            let response = try await repository.getAnnouncements()

            // TaskÍ∞Ä Ï∑®ÏÜåÎêòÏóàÎäîÏßÄ ÌôïÏù∏
            if Task.isCancelled {
                print("[AnnouncementsViewModel] Task was cancelled, ignoring result")
                isLoading = false
                return
            }

            pinnedAnnouncements = response.pinned
            unpinnedAnnouncements = response.unpinned
            print("Successfully loaded announcements: \(response.pinned.count) pinned, \(response.unpinned.count) unpinned")

        } catch is CancellationError {
            print("[AnnouncementsViewModel] Task cancelled - this is expected during refresh")
            isLoading = false
            return

        } catch {
            // TaskÍ∞Ä Ï∑®ÏÜåÎêòÏóàÎã§Î©¥ ÏóêÎü¨ Ï≤òÎ¶¨ÌïòÏßÄ ÏïäÏùå
            if Task.isCancelled {
                print("[AnnouncementsViewModel] Task cancelled, ignoring error")
                isLoading = false
                return
            }

            // cancelled ÏóêÎü¨Îäî ÏÉàÎ°úÍ≥†Ïπ® Í≥ºÏ†ïÏóêÏÑú Î∞úÏÉùÌïòÎäî Ï†ïÏÉÅ Ï∑®ÏÜåÏù¥ÎØÄÎ°ú Î¨¥Ïãú
            if let nsError = error as NSError?, nsError.code == -999 {
                print("[AnnouncementsViewModel] Request cancelled (Ï†ïÏÉÅ Ï∑®ÏÜå): \(error)")
                isLoading = false
                return // ÏóêÎü¨ ÏÉÅÌÉúÎ°ú ÌëúÏãúÌïòÏßÄ ÏïäÏùå
            }

            errorMessage = "Í≥µÏßÄÏÇ¨Ìï≠ÏùÑ Î∂àÎü¨Ïò§ÎäîÎç∞ Ïã§Ìå®ÌñàÏäµÎãàÎã§."
            print("Error loading announcements: \(error)")
            // ÏßÑÏßú ÏóêÎü¨ ÏãúÏóêÎßå Îπà Î∞∞Ïó¥ ÌëúÏãú
            pinnedAnnouncements = []
            unpinnedAnnouncements = []
        }

        isLoading = false
    }
}

struct FAQListView: View {
    @ObservedObject var viewModel: FAQViewModel

    var body: some View {
        ScrollView {
            LazyVStack(spacing: 12) {
                if viewModel.isLoading && viewModel.faqs.isEmpty {
                    // Ï¥àÍ∏∞ Î°úÎî© ÏÉÅÌÉú
                    ProgressView("FAQÎ•º Î∂àÎü¨Ïò§Îäî Ï§ë...")
                        .padding(.vertical, 40)
                } else if !viewModel.isLoading && viewModel.faqs.isEmpty {
                    // Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÎäî ÏÉÅÌÉú
                    if let errorMessage = viewModel.errorMessage {
                        VStack(spacing: 12) {
                            Image(systemName: "exclamationmark.triangle")
                                .font(.system(size: 24))
                                .foregroundColor(.gray)
                            Text(errorMessage)
                                .font(.system(size: 14))
                                .foregroundColor(.gray)
                                .multilineTextAlignment(.center)
                        }
                        .padding(.vertical, 40)
                    } else {
                        VStack(spacing: 12) {
                            Image(systemName: "questionmark.circle")
                                .font(.system(size: 24))
                                .foregroundColor(.gray)
                            Text("Îì±Î°ùÎêú FAQÍ∞Ä ÏóÜÏäµÎãàÎã§")
                                .font(.system(size: 14))
                                .foregroundColor(.gray)
                        }
                        .padding(.vertical, 40)
                    }
                } else {
                    ForEach(viewModel.faqs) { faq in
                        FAQCard(faq: faq)
                    }
                }
            }
            .padding(.horizontal, 20)
            .padding(.top, 16)
            .padding(.bottom, 100)
        }
        .refreshable {
            await viewModel.loadFAQs()
        }
    }
}

struct FAQCard: View {
    let faq: FAQ
    @State private var isExpanded = false

    var body: some View {
        Button(action: {
            withAnimation(.easeInOut(duration: 0.3)) {
                isExpanded.toggle()
            }
        }) {
            VStack(alignment: .leading, spacing: 0) {
                // ÏÉÅÎã®: Q. Ï†úÎ™© + ÏïÑÏù¥ÏΩò (Ìïú Ï§Ñ)
                HStack(alignment: .center, spacing: 12) {
                    // Q. Ï†úÎ™©
                    Text("Q. \(faq.question)")
                        .font(.system(size: 15, weight: .medium))
                        .foregroundColor(.black)
                        .multilineTextAlignment(.leading)
                        .frame(maxWidth: .infinity, alignment: .leading)

                    // Ïò§Î•∏Ï™Ω ÏïÑÏù¥ÏΩò
                    Image(systemName: isExpanded ? "chevron.up" : "chevron.down")
                        .font(.system(size: 14, weight: .medium))
                        .foregroundColor(.gray)
                        .transition(.opacity.combined(with: .scale))
                }
                .padding(.bottom, isExpanded ? 12 : 0)

                // ÌïòÎã®: Î≥∏Î¨∏ (ÌéºÏ≥êÏ°åÏùÑ ÎïåÎßå ÌëúÏãú)
                if isExpanded {
                    Text(faq.answer)
                        .font(.system(size: 14))
                        .foregroundColor(.black)
                        .multilineTextAlignment(.leading)
                        .lineLimit(nil)
                        .frame(maxWidth: .infinity, alignment: .leading)
                        .transition(.opacity.combined(with: .scale(scale: 0.95, anchor: .top)))
                }
            }
            .padding(16)
            .background(
                RoundedRectangle(cornerRadius: 12)
                    .fill(Color(red: 0.97, green: 0.97, blue: 0.97)) // pinned Í≥µÏßÄÏôÄ ÎèôÏùºÌïú Ïó∞Ìïú ÌöåÏÉâ
                    .overlay(
                        RoundedRectangle(cornerRadius: 12)
                            .stroke(Color.gray.opacity(0.4), lineWidth: 1)
                    )
            )
        }
        .buttonStyle(PlainButtonStyle())
    }
}

@MainActor
class FAQViewModel: ObservableObject {
    @Published var faqs: [FAQ] = []
    @Published var isLoading = false
    @Published var errorMessage: String?

    private let repository: FAQRepository
    private var loadTask: Task<Void, Never>?

    init(repository: FAQRepository) {
        self.repository = repository
    }

    func loadFAQs() async {
        // Í∏∞Ï°¥ Task Ï∑®ÏÜå
        loadTask?.cancel()

        // ÏÉàÎ°úÏö¥ Task ÏÉùÏÑ±
        loadTask = Task {
            await performLoad()
        }

        await loadTask?.value
    }

    private func performLoad() async {
        print("[FAQViewModel] üìû API Ìò∏Ï∂ú ÏãúÏûë - FAQ Î°úÎìú")
        isLoading = true
        errorMessage = nil

        // ÏÉàÎ°úÍ≥†Ïπ® ÌëúÏãúÎ•º ÏúÑÌï¥ Îç∞Ïù¥ÌÑ∞ Ï¥àÍ∏∞Ìôî
        faqs = []

        do {
            let loadedFAQs = try await repository.getFAQs()

            // TaskÍ∞Ä Ï∑®ÏÜåÎêòÏóàÎäîÏßÄ ÌôïÏù∏
            if Task.isCancelled {
                print("[FAQViewModel] Task was cancelled, ignoring result")
                isLoading = false
                return
            }

            // sequence ÏàúÏÑúÎåÄÎ°ú Ï†ïÎ†¨
            faqs = loadedFAQs.sorted { $0.sequence < $1.sequence }
            print("Successfully loaded FAQs: \(faqs.count) items")

        } catch is CancellationError {
            print("[FAQViewModel] Task cancelled - this is expected during refresh")
            isLoading = false
            return

        } catch {
            // TaskÍ∞Ä Ï∑®ÏÜåÎêòÏóàÎã§Î©¥ ÏóêÎü¨ Ï≤òÎ¶¨ÌïòÏßÄ ÏïäÏùå
            if Task.isCancelled {
                print("[FAQViewModel] Task cancelled, ignoring error")
                isLoading = false
                return
            }

            // cancelled ÏóêÎü¨Îäî ÏÉàÎ°úÍ≥†Ïπ® Í≥ºÏ†ïÏóêÏÑú Î∞úÏÉùÌïòÎäî Ï†ïÏÉÅ Ï∑®ÏÜåÏù¥ÎØÄÎ°ú Î¨¥Ïãú
            if let nsError = error as NSError?, nsError.code == -999 {
                print("[FAQViewModel] Request cancelled (Ï†ïÏÉÅ Ï∑®ÏÜå): \(error)")
                isLoading = false
                return // ÏóêÎü¨ ÏÉÅÌÉúÎ°ú ÌëúÏãúÌïòÏßÄ ÏïäÏùå
            }

            errorMessage = "FAQÎ•º Î∂àÎü¨Ïò§ÎäîÎç∞ Ïã§Ìå®ÌñàÏäµÎãàÎã§."
            print("Error loading FAQs: \(error)")
            // ÏßÑÏßú ÏóêÎü¨ ÏãúÏóêÎßå Îπà Î∞∞Ïó¥ ÌëúÏãú
            faqs = []
        }

        isLoading = false
    }
}
